Z     <- cbind(1,
vix$value[2:(T-1)],sen$value[2:(T-1)],
doil[2:(T-1)],dsto[2:(T-1)],dbdr[2:(T-1)]
)
R_tp1 <- cbind(doil[3:T],dsto[3:T],dbdr[3:T])
f_aux <- function(theta){
b_M <- matrix(theta[1:n_F],ncol=1)
b_F <- matrix(theta[(n_F+1):(n_F + n_F*n_z)],n_F,n_z)
b_aux <- (F_tp1 - Z %*% t(b_F)) %*% b_M
b_aux <- matrix(b_aux,T-2,n_R)
R_aux <- b_aux * R_tp1 - R_tp1 + 1
mom_R <- (R_aux %x% matrix(1,1,n_z)) * (matrix(1,1,n_R) %x% Z)
F_aux <- (F_tp1 - Z %*% t(b_F))
mom_F <- (F_aux %x% matrix(1,1,n_z)) * (matrix(1,1,n_F) %x% Z)
H     <- cbind(mom_R,mom_F)
Gamma0 <- 1/T * t(H) %*% H
g <- matrix(apply(H,2,mean),ncol=1)
res <- c(t(g) %*% ginv(Gamma0) %*% g)
return(list(g=g,H=H,res=res,Gamma0=Gamma0))
}
f2beMin <- function(theta){f_aux(theta)$res}
theta0 <- c(-1,1,t(ginv(t(Z)%*%Z)%*%t(Z)%*% F_tp1))
res.optim <- optim(theta0,f2beMin,
method="BFGS", # could be "Nelder-Mead"
control=list(trace=TRUE,maxit=300),hessian=TRUE)
theta <- res.optim$par
theta
# Computation of D:
eps <- .00001
g0 <- f_aux(theta)$g
D <- NULL
for(i in 1:length(theta)){
theta.i <- theta
theta.i[i] <- theta.i[i] + eps
gi <- f_aux(theta.i)$g
D <- cbind(D,(gi-g0)/eps)
}
S <- f_aux(theta)$Gamma0
V <- solve(t(D)%*%solve(S)%*%D)
cbind(theta,sqrt(diag(V)))
cbind(theta0,theta,sqrt(diag(V)))
theta0 <- c(-1,1,t(solve(t(Z)%*%Z)%*%t(Z)%*% F_tp1))
theta0
solve(t(Z)%*%Z)%*%t(Z)%*% F_tp1
theta0 <- c(-1,1,solve(t(Z)%*%Z)%*%t(Z)%*% F_tp1)
res.optim <- optim(theta0,f2beMin,
method="BFGS", # could be "Nelder-Mead"
control=list(trace=TRUE,maxit=300),hessian=TRUE)
theta <- res.optim$par
#library(quantmod,TTR)
#data <- getSymbols('INTC',src='yahoo',auto.assign=FALSE)
#plot(data$INTC.Close,main = 'Intel Stock Price')
library(fredr)
library(MASS)
fredr_set_key("df65e14c054697a52b4511e77fcfa1f3")
start_date <- as.Date("1990-01-01"); end_date <- as.Date("2019-01-01")
f <- function(ticker){
fredr(series_id = ticker,
observation_start = start_date,
observation_end = end_date,
frequency = "m",aggregation_method = "avg")
}
oil <- f("DCOILWTICO") # oil price (WTI)
vix <- f("VIXCLS") # VIX
sen <- f("UMCSENT") # U. of Michigan consument sentiment index
sto <- f("WILL5000PRFC") # Wilshire 5000 Full Cap Price Index
bdr <- f("BAMLCC0A4BBBTRIV") # ICE BofA BBB US Corporate Index Total Return Index
T <- dim(oil)[1]
doil <- c(NaN,oil$value[2:T]/oil$value[1:(T-1)]) # return
dsto <- c(NaN,sto$value[2:T]/sto$value[1:(T-1)]) # return
dbdr <- c(NaN,bdr$value[2:T]/bdr$value[1:(T-1)]) # return
n_F <- 2; n_R <- 3; n_z <- 6
F_tp1 <- cbind(vix$value[3:T],sen$value[3:T])
R_tp1 <- cbind(doil[3:T],dsto[3:T],dbdr[3:T])
Z     <- cbind(1,
vix$value[2:(T-1)],sen$value[2:(T-1)],
doil[2:(T-1)],dsto[2:(T-1)],dbdr[2:(T-1)]
)
R_tp1 <- cbind(doil[3:T],dsto[3:T],dbdr[3:T])
f_aux <- function(theta){
b_M <- matrix(theta[1:n_F],ncol=1)
b_F <- matrix(theta[(n_F+1):(n_F + n_F*n_z)],n_F,n_z)
b_aux <- (F_tp1 - Z %*% t(b_F)) %*% b_M
b_aux <- matrix(b_aux,T-2,n_R)
R_aux <- b_aux * R_tp1 - R_tp1 + 1
mom_R <- (R_aux %x% matrix(1,1,n_z)) * (matrix(1,1,n_R) %x% Z)
F_aux <- (F_tp1 - Z %*% t(b_F))
mom_F <- (F_aux %x% matrix(1,1,n_z)) * (matrix(1,1,n_F) %x% Z)
H     <- cbind(mom_R,mom_F)
Gamma0 <- 1/T * t(H) %*% H
g <- matrix(apply(H,2,mean),ncol=1)
res <- c(t(g) %*% ginv(Gamma0) %*% g)
return(list(g=g,H=H,res=res,Gamma0=Gamma0))
}
f2beMin <- function(theta){f_aux(theta)$res}
theta0 <- c(-1,1,solve(t(Z)%*%Z)%*%t(Z)%*% F_tp1)
res.optim <- optim(theta0,f2beMin,
method="BFGS", # could be "Nelder-Mead"
control=list(trace=TRUE,maxit=300),hessian=TRUE)
theta <- res.optim$par
theta
# Computation of D:
eps <- .00001
g0 <- f_aux(theta)$g
D <- NULL
for(i in 1:length(theta)){
theta.i <- theta
theta.i[i] <- theta.i[i] + eps
gi <- f_aux(theta.i)$g
D <- cbind(D,(gi-g0)/eps)
}
S <- f_aux(theta)$Gamma0
V <- solve(t(D)%*%solve(S)%*%D)
cbind(theta0,theta,sqrt(diag(V)))
#library(quantmod,TTR)
#data <- getSymbols('INTC',src='yahoo',auto.assign=FALSE)
#plot(data$INTC.Close,main = 'Intel Stock Price')
library(fredr)
library(MASS)
fredr_set_key("df65e14c054697a52b4511e77fcfa1f3")
start_date <- as.Date("1990-01-01"); end_date <- as.Date("2019-01-01")
f <- function(ticker){
fredr(series_id = ticker,
observation_start = start_date,
observation_end = end_date,
frequency = "m",aggregation_method = "avg")
}
oil <- f("DCOILWTICO") # oil price (WTI)
vix <- f("VIXCLS") # VIX
sen <- f("UMCSENT") # U. of Michigan consument sentiment index
sto <- f("WILL5000PRFC") # Wilshire 5000 Full Cap Price Index
bdr <- f("BAMLCC0A4BBBTRIV") # ICE BofA BBB US Corporate Index Total Return Index
T <- dim(oil)[1]
doil <- c(NaN,oil$value[2:T]/oil$value[1:(T-1)]) # return
dsto <- c(NaN,sto$value[2:T]/sto$value[1:(T-1)]) # return
dbdr <- c(NaN,bdr$value[2:T]/bdr$value[1:(T-1)]) # return
n_F <- 2; n_R <- 3; n_z <- 6
F_tp1 <- cbind(vix$value[3:T],sen$value[3:T])
R_tp1 <- cbind(doil[3:T],dsto[3:T],dbdr[3:T])
Z     <- cbind(1,
vix$value[2:(T-1)],sen$value[2:(T-1)],
doil[2:(T-1)],dsto[2:(T-1)],dbdr[2:(T-1)]
)
R_tp1 <- cbind(doil[3:T],dsto[3:T],dbdr[3:T])
f_aux <- function(theta){
b_M <- matrix(theta[1:n_F],ncol=1)
b_F <- matrix(theta[(n_F+1):(n_F + n_F*n_z)],n_F,n_z)
b_aux <- (F_tp1 - Z %*% t(b_F)) %*% b_M
b_aux <- matrix(b_aux,T-2,n_R)
R_aux <- b_aux * R_tp1 - R_tp1 + 1
mom_R <- (R_aux %x% matrix(1,1,n_z)) * (matrix(1,1,n_R) %x% Z)
F_aux <- (F_tp1 - Z %*% t(b_F))
mom_F <- (F_aux %x% matrix(1,1,n_z)) * (matrix(1,1,n_F) %x% Z)
H     <- cbind(mom_R,mom_F)
Gamma0 <- 1/T * t(H) %*% H
g <- matrix(apply(H,2,mean),ncol=1)
res <- c(t(g) %*% solve(Gamma0) %*% g)
return(list(g=g,H=H,res=res,Gamma0=Gamma0))
}
f2beMin <- function(theta){f_aux(theta)$res}
theta0 <- c(-1,1,solve(t(Z)%*%Z)%*%t(Z)%*% F_tp1)
res.optim <- optim(theta0,f2beMin,
method="BFGS", # could be "Nelder-Mead"
control=list(trace=TRUE,maxit=300),hessian=TRUE)
theta <- res.optim$par
theta
# Computation of D:
eps <- .00001
g0 <- f_aux(theta)$g
D <- NULL
for(i in 1:length(theta)){
theta.i <- theta
theta.i[i] <- theta.i[i] + eps
gi <- f_aux(theta.i)$g
D <- cbind(D,(gi-g0)/eps)
}
S <- f_aux(theta)$Gamma0
V <- solve(t(D)%*%solve(S)%*%D)
cbind(theta0,theta,sqrt(diag(V)))
f2beMin <- function(theta){f_aux(theta)$res}
theta0 <- c(-1,1,solve(t(Z)%*%Z)%*%t(Z)%*% F_tp1)
res.optim <- optim(theta0,f2beMin,
method="Nelder-Mead", # could be "Nelder-Mead"
control=list(trace=TRUE,maxit=300),hessian=TRUE)
theta <- res.optim$par
theta
f2beMin <- function(theta){f_aux(theta)$res}
theta0 <- c(-1,1,solve(t(Z)%*%Z)%*%t(Z)%*% F_tp1)
res.optim <- optim(theta0,f2beMin,
method="Nelder-Mead", # could be "Nelder-Mead"
control=list(trace=TRUE,maxit=1000),hessian=TRUE)
#library(quantmod,TTR)
#data <- getSymbols('INTC',src='yahoo',auto.assign=FALSE)
#plot(data$INTC.Close,main = 'Intel Stock Price')
library(fredr)
library(MASS)
fredr_set_key("df65e14c054697a52b4511e77fcfa1f3")
start_date <- as.Date("1990-01-01"); end_date <- as.Date("2019-01-01")
f <- function(ticker){
fredr(series_id = ticker,
observation_start = start_date,
observation_end = end_date,
frequency = "m",aggregation_method = "avg")
}
oil <- f("DCOILWTICO") # oil price (WTI)
vix <- f("VIXCLS") # VIX
sen <- f("UMCSENT") # U. of Michigan consument sentiment index
sto <- f("WILL5000PRFC") # Wilshire 5000 Full Cap Price Index
bdr <- f("BAMLCC0A4BBBTRIV") # ICE BofA BBB US Corporate Index Total Return Index
T <- dim(oil)[1]
doil <- c(NaN,oil$value[2:T]/oil$value[1:(T-1)]) # return
dsto <- c(NaN,sto$value[2:T]/sto$value[1:(T-1)]) # return
dbdr <- c(NaN,bdr$value[2:T]/bdr$value[1:(T-1)]) # return
n_F <- 2; n_R <- 3; n_z <- 6
F_tp1 <- cbind(vix$value[3:T],sen$value[3:T])
R_tp1 <- cbind(doil[3:T],dsto[3:T],dbdr[3:T])
Z     <- cbind(1,
vix$value[2:(T-1)],sen$value[2:(T-1)],
doil[2:(T-1)],dsto[2:(T-1)],dbdr[2:(T-1)]
)
R_tp1 <- cbind(doil[3:T],dsto[3:T],dbdr[3:T])
f_aux <- function(theta){
b_M <- matrix(theta[1:n_F],ncol=1)
b_F <- matrix(theta[(n_F+1):(n_F + n_F*n_z)],n_F,n_z)
b_aux <- (F_tp1 - Z %*% t(b_F)) %*% b_M
b_aux <- matrix(b_aux,T-2,n_R)
R_aux <- b_aux * R_tp1 - R_tp1 + 1
mom_R <- (R_aux %x% matrix(1,1,n_z)) * (matrix(1,1,n_R) %x% Z)
F_aux <- (F_tp1 - Z %*% t(b_F))
mom_F <- (F_aux %x% matrix(1,1,n_z)) * (matrix(1,1,n_F) %x% Z)
H     <- cbind(mom_R,mom_F)
Gamma0 <- 1/T * t(H) %*% H
g <- matrix(apply(H,2,mean),ncol=1)
res <- c(t(g) %*% ginv(Gamma0) %*% g)
return(list(g=g,H=H,res=res,Gamma0=Gamma0))
}
f2beMin <- function(theta){f_aux(theta)$res}
theta0 <- c(-1,1,solve(t(Z)%*%Z)%*%t(Z)%*% F_tp1)
res.optim <- optim(theta0,f2beMin,
method="Nelder-Mead", # could be "Nelder-Mead"
control=list(trace=TRUE,maxit=1000),hessian=TRUE)
theta <- res.optim$par
theta
# Computation of D:
eps <- .00001
g0 <- f_aux(theta)$g
D <- NULL
for(i in 1:length(theta)){
theta.i <- theta
theta.i[i] <- theta.i[i] + eps
gi <- f_aux(theta.i)$g
D <- cbind(D,(gi-g0)/eps)
}
S <- f_aux(theta)$Gamma0
V <- solve(t(D)%*%solve(S)%*%D)
cbind(theta0,theta,sqrt(diag(V)))
g0 <- f_aux(theta)$g
g0
#library(quantmod,TTR)
#data <- getSymbols('INTC',src='yahoo',auto.assign=FALSE)
#plot(data$INTC.Close,main = 'Intel Stock Price')
library(fredr)
library(MASS)
fredr_set_key("df65e14c054697a52b4511e77fcfa1f3")
start_date <- as.Date("1990-01-01"); end_date <- as.Date("2019-01-01")
f <- function(ticker){
fredr(series_id = ticker,
observation_start = start_date,
observation_end = end_date,
frequency = "m",aggregation_method = "avg")
}
oil <- f("DCOILWTICO") # oil price (WTI)
vix <- f("VIXCLS") # VIX
sen <- f("UMCSENT") # U. of Michigan consument sentiment index
sto <- f("WILL5000PRFC") # Wilshire 5000 Full Cap Price Index
bdr <- f("BAMLCC0A4BBBTRIV") # ICE BofA BBB US Corporate Index Total Return Index
T <- dim(oil)[1]
doil <- c(NaN,oil$value[2:T]/oil$value[1:(T-1)]) # return
dsto <- c(NaN,sto$value[2:T]/sto$value[1:(T-1)]) # return
dbdr <- c(NaN,bdr$value[2:T]/bdr$value[1:(T-1)]) # return
n_F <- 2; n_R <- 3; n_z <- 6
F_tp1 <- cbind(vix$value[3:T],sen$value[3:T])
R_tp1 <- cbind(doil[3:T],dsto[3:T],dbdr[3:T])
Z     <- cbind(1,
vix$value[2:(T-1)],sen$value[2:(T-1)],
doil[2:(T-1)],dsto[2:(T-1)],dbdr[2:(T-1)]
)
R_tp1 <- cbind(doil[3:T],dsto[3:T],dbdr[3:T])
f_aux <- function(theta){
b_M <- matrix(theta[1:n_F],ncol=1)
b_F <- matrix(theta[(n_F+1):(n_F + n_F*n_z)],n_F,n_z)
b_aux <- (F_tp1 - Z %*% t(b_F)) %*% b_M
b_aux <- matrix(b_aux,T-2,n_R)
R_aux <- b_aux * R_tp1 - R_tp1 + 1
mom_R <- (R_aux %x% matrix(1,1,n_z)) * (matrix(1,1,n_R) %x% Z)
F_aux <- (F_tp1 - Z %*% t(b_F))
mom_F <- (F_aux %x% matrix(1,1,n_z)) * (matrix(1,1,n_F) %x% Z)
H     <- cbind(mom_R,mom_F)
Gamma0 <- 1/T * t(H) %*% H
g <- matrix(apply(H,2,mean),ncol=1)
res <- c(t(g) %*% solve(Gamma0) %*% g)
return(list(g=g,H=H,res=res,Gamma0=Gamma0))
}
f2beMin <- function(theta){f_aux(theta)$res}
theta0 <- c(-1,1,solve(t(Z)%*%Z)%*%t(Z)%*% F_tp1)
res.optim <- optim(theta0,f2beMin,
method="Nelder-Mead", # could be "Nelder-Mead"
control=list(trace=TRUE,maxit=1000),hessian=TRUE)
#library(quantmod,TTR)
#data <- getSymbols('INTC',src='yahoo',auto.assign=FALSE)
#plot(data$INTC.Close,main = 'Intel Stock Price')
library(fredr)
library(MASS)
fredr_set_key("df65e14c054697a52b4511e77fcfa1f3")
start_date <- as.Date("1990-01-01"); end_date <- as.Date("2019-01-01")
f <- function(ticker){
fredr(series_id = ticker,
observation_start = start_date,
observation_end = end_date,
frequency = "m",aggregation_method = "avg")
}
oil <- f("DCOILWTICO") # oil price (WTI)
vix <- f("VIXCLS") # VIX
sen <- f("UMCSENT") # U. of Michigan consument sentiment index
sto <- f("WILL5000PRFC") # Wilshire 5000 Full Cap Price Index
bdr <- f("BAMLCC0A4BBBTRIV") # ICE BofA BBB US Corporate Index Total Return Index
T <- dim(oil)[1]
doil <- c(NaN,oil$value[2:T]/oil$value[1:(T-1)]) # return
dsto <- c(NaN,sto$value[2:T]/sto$value[1:(T-1)]) # return
dbdr <- c(NaN,bdr$value[2:T]/bdr$value[1:(T-1)]) # return
n_F <- 2; n_R <- 3; n_z <- 6
F_tp1 <- cbind(vix$value[3:T],sen$value[3:T])
R_tp1 <- cbind(doil[3:T],dsto[3:T],dbdr[3:T])
Z     <- cbind(1,
vix$value[2:(T-1)],sen$value[2:(T-1)],
doil[2:(T-1)],dsto[2:(T-1)],dbdr[2:(T-1)]
)
R_tp1 <- cbind(doil[3:T],dsto[3:T],dbdr[3:T])
f_aux <- function(theta){
b_M <- matrix(theta[1:n_F],ncol=1)
b_F <- matrix(theta[(n_F+1):(n_F + n_F*n_z)],n_F,n_z)
b_aux <- (F_tp1 - Z %*% t(b_F)) %*% b_M
b_aux <- matrix(b_aux,T-2,n_R)
R_aux <- b_aux * R_tp1 - R_tp1 + 1
mom_R <- (R_aux %x% matrix(1,1,n_z)) * (matrix(1,1,n_R) %x% Z)
F_aux <- (F_tp1 - Z %*% t(b_F))
mom_F <- (F_aux %x% matrix(1,1,n_z)) * (matrix(1,1,n_F) %x% Z)
H     <- cbind(mom_R,mom_F)
Gamma0 <- 1/T * t(H) %*% H
print(eigen(Gamma0)$values)
g <- matrix(apply(H,2,mean),ncol=1)
res <- c(t(g) %*% solve(Gamma0) %*% g)
return(list(g=g,H=H,res=res,Gamma0=Gamma0))
}
f2beMin <- function(theta){f_aux(theta)$res}
theta0 <- c(-1,1,solve(t(Z)%*%Z)%*%t(Z)%*% F_tp1)
res.optim <- optim(theta0,f2beMin,
method="Nelder-Mead", # could be "Nelder-Mead"
control=list(trace=TRUE,maxit=1000),hessian=TRUE)
theta0 <- c(0,0,solve(t(Z)%*%Z)%*%t(Z)%*% F_tp1)
res <- f_aux(theta0)
f_aux <- function(theta){
b_M <- matrix(theta[1:n_F],ncol=1)
b_F <- matrix(theta[(n_F+1):(n_F + n_F*n_z)],n_F,n_z)
b_aux <- (F_tp1 - Z %*% t(b_F)) %*% b_M
b_aux <- matrix(b_aux,T-2,n_R)
R_aux <- b_aux * R_tp1 - R_tp1 + 1
mom_R <- (R_aux %x% matrix(1,1,n_z)) * (matrix(1,1,n_R) %x% Z)
F_aux <- (F_tp1 - Z %*% t(b_F))
mom_F <- (F_aux %x% matrix(1,1,n_z)) * (matrix(1,1,n_F) %x% Z)
H     <- cbind(mom_R,mom_F)
print(eigen(Gamma0)$values)
g <- matrix(apply(H,2,mean),ncol=1)
res <- c(t(g) %*% solve(Gamma0) %*% g)
return(list(g=g,H=H))
}
theta0 <- c(0,0,solve(t(Z)%*%Z)%*%t(Z)%*% F_tp1)
res <- f_aux(theta0)
f_aux <- function(theta){
b_M <- matrix(theta[1:n_F],ncol=1)
b_F <- matrix(theta[(n_F+1):(n_F + n_F*n_z)],n_F,n_z)
b_aux <- (F_tp1 - Z %*% t(b_F)) %*% b_M
b_aux <- matrix(b_aux,T-2,n_R)
R_aux <- b_aux * R_tp1 - R_tp1 + 1
mom_R <- (R_aux %x% matrix(1,1,n_z)) * (matrix(1,1,n_R) %x% Z)
F_aux <- (F_tp1 - Z %*% t(b_F))
mom_F <- (F_aux %x% matrix(1,1,n_z)) * (matrix(1,1,n_F) %x% Z)
H     <- cbind(mom_R,mom_F)
print(eigen(Gamma0)$values)
g <- matrix(apply(H,2,mean),ncol=1)
return(list(g=g,H=H))
}
theta0 <- c(0,0,solve(t(Z)%*%Z)%*%t(Z)%*% F_tp1)
res <- f_aux(theta0)
R_tp1 <- cbind(doil[3:T],dsto[3:T],dbdr[3:T])
f_aux <- function(theta){
b_M <- matrix(theta[1:n_F],ncol=1)
b_F <- matrix(theta[(n_F+1):(n_F + n_F*n_z)],n_F,n_z)
b_aux <- (F_tp1 - Z %*% t(b_F)) %*% b_M
b_aux <- matrix(b_aux,T-2,n_R)
R_aux <- b_aux * R_tp1 - R_tp1 + 1
mom_R <- (R_aux %x% matrix(1,1,n_z)) * (matrix(1,1,n_R) %x% Z)
F_aux <- (F_tp1 - Z %*% t(b_F))
mom_F <- (F_aux %x% matrix(1,1,n_z)) * (matrix(1,1,n_F) %x% Z)
H     <- cbind(mom_R,mom_F)
g <- matrix(apply(H,2,mean),ncol=1)
return(list(g=g,H=H))
}
theta0 <- c(0,0,solve(t(Z)%*%Z)%*%t(Z)%*% F_tp1)
res <- f_aux(theta0)
W <- solve(1/T * t(res$H) %*% res$H)
theta0 <- c(0,0,solve(t(Z)%*%Z)%*%t(Z)%*% F_tp1)
res <- f_aux(theta0)
W <- solve(1/T * t(res$H) %*% res$H)
theta0
theta0 <- c(0.1,0,solve(t(Z)%*%Z)%*%t(Z)%*% F_tp1)
res <- f_aux(theta0)
W <- solve(1/T * t(res$H) %*% res$H)
f2beMin <- function(theta){
res <- f_aux(theta)
return(t(res$g) %*% W %*% res$g)
}
res.optim <- optim(theta0,f2beMin,
method="Nelder-Mead", # could be "Nelder-Mead"
control=list(trace=TRUE,maxit=1000),hessian=TRUE)
res.optim <- optim(theta0,f2beMin,
method="BFGS", # could be "Nelder-Mead"
control=list(trace=TRUE,maxit=1000),hessian=TRUE)
theta <- res.optim$par
theta
b_M <- matrix(theta[1:n_F],ncol=1)
b_F <- matrix(theta[(n_F+1):(n_F + n_F*n_z)],n_F,n_z)
b_M
b_F
theta <- c(0.1,0,solve(t(Z)%*%Z)%*%t(Z)%*% F_tp1)
for(i in 1:3){
res <- f_aux(theta)
W <- solve(1/T * t(res$H) %*% res$H)
f2beMin <- function(theta){
res <- f_aux(theta)
return(t(res$g) %*% W %*% res$g)
}
res.optim <- optim(theta0,f2beMin,
method="BFGS", # could be "Nelder-Mead"
control=list(trace=TRUE,maxit=100),hessian=TRUE)
theta <- res.optim$par
}
theta
b_M <- matrix(theta[1:n_F],ncol=1)
b_F <- matrix(theta[(n_F+1):(n_F + n_F*n_z)],n_z,n_F)
b_aux <- (F_tp1 - Z %*% t(b_F)) %*% b_M
b_M <- matrix(theta[1:n_F],ncol=1)
b_F <- t(matrix(theta[(n_F+1):(n_F + n_F*n_z)],n_z,n_F))
b_aux <- (F_tp1 - Z %*% t(b_F)) %*% b_M
b_aux <- matrix(b_aux,T-2,n_R)
R_aux <- b_aux * R_tp1 - R_tp1 + 1
mom_R <- (R_aux %x% matrix(1,1,n_z)) * (matrix(1,1,n_R) %x% Z)
F_aux <- (F_tp1 - Z %*% t(b_F))
mom_F <- (F_aux %x% matrix(1,1,n_z)) * (matrix(1,1,n_F) %x% Z)
R_tp1 <- cbind(doil[3:T],dsto[3:T],dbdr[3:T])
f_aux <- function(theta){
b_M <- matrix(theta[1:n_F],ncol=1)
b_F <- t(matrix(theta[(n_F+1):(n_F + n_F*n_z)],n_z,n_F))
b_aux <- (F_tp1 - Z %*% t(b_F)) %*% b_M
b_aux <- matrix(b_aux,T-2,n_R)
R_aux <- b_aux * R_tp1 - R_tp1 + 1
mom_R <- (R_aux %x% matrix(1,1,n_z)) * (matrix(1,1,n_R) %x% Z)
F_aux <- (F_tp1 - Z %*% t(b_F))
mom_F <- (F_aux %x% matrix(1,1,n_z)) * (matrix(1,1,n_F) %x% Z)
H     <- cbind(mom_R,mom_F)
g <- matrix(apply(H,2,mean),ncol=1)
return(list(g=g,H=H))
}
theta <- c(0.1,0,solve(t(Z)%*%Z)%*%t(Z)%*% F_tp1)
for(i in 1:3){
res <- f_aux(theta)
W <- solve(1/T * t(res$H) %*% res$H)
f2beMin <- function(theta){
res <- f_aux(theta)
return(t(res$g) %*% W %*% res$g)
}
res.optim <- optim(theta0,f2beMin,
method="BFGS", # could be "Nelder-Mead"
control=list(trace=TRUE,maxit=100),hessian=TRUE)
theta <- res.optim$par
}
theta <- c(0.1,0,solve(t(Z)%*%Z)%*%t(Z)%*% F_tp1)
for(i in 1:3){
res <- f_aux(theta)
W <- solve(1/T * t(res$H) %*% res$H)
f2beMin <- function(theta){
res <- f_aux(theta)
return(t(res$g) %*% W %*% res$g)
}
res.optim <- optim(theta,f2beMin,
method="BFGS", # could be "Nelder-Mead"
control=list(trace=TRUE,maxit=100),hessian=TRUE)
theta <- res.optim$par
}
theta
theta
eps <- .00001
g0 <- f_aux(theta)$g
D <- NULL
for(i in 1:length(theta)){
theta.i <- theta
theta.i[i] <- theta.i[i] + eps
gi <- f_aux(theta.i)$g
D <- cbind(D,(gi-g0)/eps)
}
V <- solve(t(D)%*%W%*%D)
cbind(theta0,theta,sqrt(diag(V)))
