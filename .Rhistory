vec1 <- matrix(1,n^2,1)
Vall <- (vecC.S %*% t(vec1)) * invV * t(vecC.S %*% t(vec1))
ksi.W <- t(vecC.S) %*% invV %*% vecC.S
# detect the three elements of Sigma.B.aux with the highest modulus
aux <- c(abs(P))
aux.sorted <- sort(aux)
for(i in 1:n){
aux.indic <- which(aux>=aux.sorted[n^2-n+1])
}
R <- matrix(0,n,n^2)
R[1,aux.indic[1]] <- 1
R[2,aux.indic[2]] <- 1
R[3,aux.indic[3]] <- 1
q <- c(P[aux.indic[1]],P[aux.indic[2]],P[aux.indic[3]])
MC <- M %*% C.PML
VV <- IxM %*% V %*% t(IxM)
mat.cov.Aronde <- make.Asympt.Cov.deltaAronde(eps.PML,distri,C.PML)
p.value.W <- 1-pchisq(ksi.W,3)
if(dist.C.S < dist.C.S.best){
dist.C.S.best <- dist.C.S
p.value.W.best <- p.value.W
ksi.W.best <- ksi.W
B.permut.best <- t(all.permut[,,c.permut])
c.permut.best <- c.permut
P.j.best <- P
Vall.best <- Vall
VecC.S.best <- vecC.S
eigen.best <- eigen(C.PML %*% P - Sigma.B.aux)$value
}
}
print(P.j.best)
print(c(ksi.W.best,p.value.W.best,c.permut.best))
print(min(abs(eigen.best)))
Sigma.B
BB.Chol <- B
# all.permut contains all transformations of identity
# (up to permutations and sign changes of columns)
# i.e. 48 matrices (= layers):
all.permut <- do.signs(do.permut(n))
p.value.W.best <- 0
ksi.value.W.best <- 0
dist.C.S.best <- 100000000
V_1 <- make.Asympt.Cov.delta_1(eps.PML,distri,C.PML)
ksi.W.best
c.permut.best
library(AEC)
distri <- list(
type=c("mixt.gaussian","mixt.gaussian","mixt.gaussian"),
df=c(NaN,NaN,NaN),
p=c(0.5,.5,.5),mu=c(.1,.1,.1),sigma=c(.5,.7,1.3))
First.date <- "1959-04-01"
Last.date  <- "2015-01-01"
data <- US3var
data <- data[(data$Date>=First.date)&(data$Date<=Last.date),]
Y <- as.matrix(data[c("infl","y.gdp.gap","r")])
estim.SVAR.ICA(Y,distri = distri,p=6)
names(estim.SVAR.ICA(Y,distri = distri,p=6))
estim.SVAR.ICA(Y,distri = distri,p=6)$C.PML
ICA.res.no.commo <- estim.SVAR.ICA(Y,distri = distri,p=6)
cbind(ICA.res.no.commo$C.PML,C.PML)
round(cbind(ICA.res.no.commo$C.PML,C.PML),3)
ICA.res.no.commo <- estim.SVAR.ICA(Y,distri = distri,p=6)
round(cbind(ICA.res.no.commo$C.PML,C.PML),3)
ICA.res.no.commo <- estim.SVAR.ICA(Y,distri = distri,p=6)
round(cbind(ICA.res.no.commo$C.PML,".",C.PML),3)
ICA.res.no.commo <- estim.SVAR.ICA(Y,distri = distri,p=6)
round(cbind(ICA.res.no.commo$C.PML,NaN,C.PML),3)
ICA.res.no.commo <- estim.SVAR.ICA(Y,distri = distri,p=6)
round(cbind(ICA.res.no.commo$C.PML,0,C.PML),3)
ICA.res.no.commo <- estim.SVAR.ICA(Y,distri = distri,p=6)
round(cbind(ICA.res.no.commo$C.PML,NaN,C.PML),3)
ICA.res.no.commo <- estim.SVAR.ICA(Y,distri = distri,p=6)
toString(round(cbind(ICA.res.no.commo$C.PML,NaN,C.PML),3))
ICA.res.no.commo <- estim.SVAR.ICA(Y,distri = distri,p=6)
round(cbind(ICA.res.no.commo$C.PML,NaN,C.PML),3)
for(iii in 1:n){
par(mfg=c(shock+1,iii))
plot(IRF.ICA[iii,,shock],type="l",lwd=2,ylab=paste("Shock ",shock,sep="")
abline(h=0,col="grey")
plot(IRF.ICA[iii,,shock],type="l",lwd=2,ylab=paste("Shock ",shock,sep=""),
abline(h=0,col="grey")
# Plot Cholesky-based IRFs:
nb.of.shock <- 3
# Plot Cholesky-based IRFs:
par(mfrow=c((n+1),n))
par(plt=c(.1,.9,.1,.7))
for(i in 1:n){
par(mfg=c(1,i))
plot(IRF.Chol[i,,3],type="l",col="red",lwd=2,
main=paste("Response of ",names.var[i],sep=""),ylab="MP shock (Cholesky)")
abline(h=0,col="grey")
}
for(shock in 1:n){
for(iii in 1:n){
par(mfg=c(shock+1,iii))
plot(IRF.ICA[iii,,shock],type="l",lwd=2,ylab=paste("Shock ",shock," (ICA)",sep=""),
abline(h=0,col="grey")
}
# Plot Cholesky-based IRFs:
par(mfrow=c((n+1),n))
par(plt=c(.1,.9,.1,.7))
for(i in 1:n){
par(mfg=c(1,i))
plot(IRF.Chol[i,,3],type="l",col="red",lwd=2,
main=paste("Response of ",names.var[i],sep=""),ylab="MP shock (Cholesky)")
abline(h=0,col="grey")
}
for(shock in 1:n){
for(iii in 1:n){
par(mfg=c(shock+1,iii))
plot(IRF.ICA[iii,,shock],type="l",lwd=2,ylab=paste("Shock ",shock," (ICA)",sep=""))
abline(h=0,col="grey")
}
}
IRF.Chol <- array(NaN,c(n,41,n))
IRF.ICA  <- array(NaN,c(n,41,n))
PHI <- list();for(i in 1:nb.lags){PHI[[i]]<-array(Phi,c(3,3,nb.lags))[,,i]}
for(jjjj in 1:n){
u.shock <- rep(0,n)
u.shock[jjjj] <- 1
IRF.Chol[,,jjjj] <- t(simul.VAR(c=rep(0,3),Phi=PHI,B=B,nb.sim=41,
y0.star=rep(0,3*nb.lags),indic.IRF = 1,u.shock = u.shock))
IRF.ICA[,,jjjj]  <- t(simul.VAR(c=rep(0,3),Phi=PHI,B=B%*%C.PML,nb.sim=41,
y0.star=rep(0,3*nb.lags),indic.IRF = 1,u.shock = u.shock))
}
# Plot Cholesky-based IRFs:
par(mfrow=c((n+1),n))
par(plt=c(.1,.9,.1,.7))
for(i in 1:n){
par(mfg=c(1,i))
plot(IRF.Chol[i,,3],type="l",col="red",lwd=2,
main=paste("Response of ",names.var[i],sep=""),ylab="MP shock (Cholesky)")
abline(h=0,col="grey")
}
for(shock in 1:n){
for(iii in 1:n){
par(mfg=c(shock+1,iii))
plot(IRF.ICA[iii,,shock],type="l",lwd=2,ylab=paste("Shock ",shock," (ICA)",sep=""))
abline(h=0,col="grey")
}
}
# Plot Cholesky-based IRFs:
par(mfrow=c((n+1),n))
par(plt=c(.2,.9,.1,.7))
for(i in 1:n){
par(mfg=c(1,i))
plot(IRF.Chol[i,,3],type="l",col="red",lwd=2,
main=paste("Response of ",names.var[i],sep=""),ylab="MP shock (Cholesky)")
abline(h=0,col="grey")
}
for(shock in 1:n){
for(iii in 1:n){
par(mfg=c(shock+1,iii))
plot(IRF.ICA[iii,,shock],type="l",lwd=2,ylab=paste("Shock ",shock," (ICA)",sep=""))
abline(h=0,col="grey")
}
}
AA.0 <- c(0,0,0)
res.optim <- optim(AA.0,func.2.minimize,
Y = u, distri = distri,
gr = d.func.2.minimize,
method="Nelder-Mead",
control=list(trace=FALSE,maxit=1000))
AA.0 <- res.optim$par
res.optim <- optim(AA.0,func.2.minimize,d.func.2.minimize,
Y = u, distri = distri,
method="BFGS",
control=list(trace=FALSE))
AA.0 <- c(0,0,0)
res.optim <- optim(AA.0,func.2.minimize,
Y = u, distri = distri,
gr = d.func.2.minimize,
method="Nelder-Mead",
control=list(trace=FALSE,maxit=1000))
AA.est <- res.optim$par
n <- ncol(Y)
M <- make.M(n)
A.est <- matrix(M %*% AA.est,n,n)
C.PML <- (diag(n) + A.est) %*% solve(diag(n) - A.est)
eps.PML <- Y %*% C.PML # eps.PML are the ICA-estimated structural shocks
A <- make.A.matrix(eps.PML,distri,C.PML)
Omega <- make.Omega(eps.PML,distri)
# Compute asymptotic covariance matrix of C.PML:
V <- make.Asympt.Cov.delta(eps.PML,distri,C.PML)
param <- c(C.PML)
st.dev <- sqrt(diag(V))
t.stat <- c(C.PML)/sqrt(diag(V))
cbind(param,st.dev,t.stat) # print results of PML estimation
library(AEC)
distri <- list(
type=c("mixt.gaussian","mixt.gaussian","mixt.gaussian"),
df=c(NaN,NaN,NaN),
p=c(0.5,.5,.5),mu=c(.1,.1,.1),sigma=c(.5,.7,1.3))
First.date <- "1959-04-01"
Last.date  <- "2015-01-01"
data <- US3var
data <- data[(data$Date>=First.date)&(data$Date<=Last.date),]
Y <- as.matrix(data[c("infl","y.gdp.gap","r")])
names.var <- c("inflation","real activity","short-term rate")
T <- dim(Y)[1]
n <- dim(Y)[2]
nb.lags <- 6 # number of lags used in the VAR model
X <- NULL
for(i in 1:nb.lags){
lagged.Y <- rbind(matrix(NaN,i,n),Y[1:(T-i),])
X <- cbind(X,lagged.Y)}
X <- cbind(X,data$commo) # add exogenous variables
Phi <- matrix(0,n,n*nb.lags);mu <- rep(0,n)
effect.commo <- rep(0,n)
Eta <- NULL # Eta is the matrix of OLS residuals
for(i in 1:n){
eq <- lm(Y[,i] ~ X)
Phi[i,] <- eq$coef[2:(dim(Phi)[2]+1)]
mu[i] <- eq$coef[1]
Eta <- cbind(Eta,eq$residuals)
effect.commo[i] <- eq$coef[length(eq$coef)]
}
Omega <- var(Eta) # Omega_1 is the covariance matrix of the OLS residuals.
B <- t(chol(Omega)) # B_1 is the Cholesky matrix associated with Omega_1 (lower triangular)
u <- Eta %*% t(solve(B)) # Recover associated structural shocks
AA.0 <- c(0,0,0)
res.optim <- optim(AA.0,func.2.minimize,
Y = u, distri = distri,
gr = d.func.2.minimize,
method="Nelder-Mead",
control=list(trace=FALSE,maxit=1000))
AA.0 <- res.optim$par
res.optim <- optim(AA.0,func.2.minimize,d.func.2.minimize,
Y = u, distri = distri,
method="BFGS",
control=list(trace=FALSE))
AA.0 <- c(0,0,0)
res.optim <- optim(AA.0,func.2.minimize,
Y = u, distri = distri,
gr = d.func.2.minimize,
method="Nelder-Mead",
control=list(trace=FALSE,maxit=1000))
AA.est <- res.optim$par
n <- ncol(Y)
M <- make.M(n)
A.est <- matrix(M %*% AA.est,n,n)
C.PML <- (diag(n) + A.est) %*% solve(diag(n) - A.est)
eps.PML <- Y %*% C.PML # eps.PML are the ICA-estimated structural shocks
A <- make.A.matrix(eps.PML,distri,C.PML)
Omega <- make.Omega(eps.PML,distri)
# Compute asymptotic covariance matrix of C.PML:
V <- make.Asympt.Cov.delta(eps.PML,distri,C.PML)
param <- c(C.PML)
st.dev <- sqrt(diag(V))
t.stat <- c(C.PML)/sqrt(diag(V))
cbind(param,st.dev,t.stat) # print results of PML estimation
V
AA.0 <- c(0,0,0)
res.optim <- optim(AA.0,func.2.minimize,
Y = u, distri = distri,
gr = d.func.2.minimize,
method="Nelder-Mead",
control=list(trace=FALSE,maxit=1000))
AA.0 <- res.optim$par
res.optim <- optim(AA.0,func.2.minimize,d.func.2.minimize,
Y = u, distri = distri,
method="BFGS",
control=list(trace=FALSE))
AA.0 <- res.optim$par
res.optim <- optim(AA.0,func.2.minimize,
Y = u, distri = distri,
gr = d.func.2.minimize,
method="Nelder-Mead",
control=list(trace=FALSE,maxit=1000))
print(res.optim$value)
if(res.optim$value < best.value){
AA.best <- res.optim$par
best.value <- res.optim$value
}
AA.est <- AA.best
n <- ncol(Y)
M <- make.M(n)
A.est <- matrix(M %*% AA.est,n,n)
C.PML <- (diag(n) + A.est) %*% solve(diag(n) - A.est)
print(C.PML)
eps.PML <- Y %*% C.PML # eps.PML are the ICA-estimated structural shocks
# Compute kurtosis:
print("kurtosis:")
print(apply(eps.PML,2,function(x){mean(x^4)}))
A <- make.A.matrix(eps.PML,distri,C.PML)
eigen(A)$value
Omega <- make.Omega(eps.PML,distri)
eigen(Omega)$value
# Compute asymptotic covariance matrix of C.PML:
V <- make.Asympt.Cov.delta(eps.PML,distri,C.PML)
V_1 <- make.Asympt.Cov.delta_1(eps.PML,distri,C.PML)
# Print results of PML estimation
res.estim <-
cbind(
c(C.PML),
sqrt(diag(V)),
c(C.PML)/sqrt(diag(V))
)
V
source("~/Desktop/prepareICA_US3varBIS.R")
eps.PML
distri
C.PML
?JB
??jarque
library(tseries)
AA.0 <- c(0,0,0)
res.optim <- optim(AA.0,func.2.minimize,
Y = u, distri = distri,
gr = d.func.2.minimize,
method="Nelder-Mead",
control=list(trace=FALSE,maxit=1000))
library(AEC)
distri <- list(
type=c("mixt.gaussian","mixt.gaussian","mixt.gaussian"),
df=c(NaN,NaN,NaN),
p=c(0.5,.5,.5),mu=c(.1,.1,.1),sigma=c(.5,.7,1.3))
First.date <- "1959-04-01"
Last.date  <- "2015-01-01"
data <- US3var
data <- data[(data$Date>=First.date)&(data$Date<=Last.date),]
Y <- as.matrix(data[c("infl","y.gdp.gap","r")])
names.var <- c("inflation","real activity","short-term rate")
T <- dim(Y)[1]
n <- dim(Y)[2]
nb.lags <- 6 # number of lags used in the VAR model
X <- NULL
for(i in 1:nb.lags){
lagged.Y <- rbind(matrix(NaN,i,n),Y[1:(T-i),])
X <- cbind(X,lagged.Y)}
X <- cbind(X,data$commo) # add exogenous variables
Phi <- matrix(0,n,n*nb.lags);mu <- rep(0,n)
effect.commo <- rep(0,n)
Eta <- NULL # Eta is the matrix of OLS residuals
for(i in 1:n){
eq <- lm(Y[,i] ~ X)
Phi[i,] <- eq$coef[2:(dim(Phi)[2]+1)]
mu[i] <- eq$coef[1]
Eta <- cbind(Eta,eq$residuals)
effect.commo[i] <- eq$coef[length(eq$coef)]
}
Omega <- var(Eta) # Omega_1 is the covariance matrix of the OLS residuals.
B <- t(chol(Omega)) # B_1 is the Cholesky matrix associated with Omega_1 (lower triangular)
u <- Eta %*% t(solve(B)) # Recover associated structural shocks
AA.0 <- c(0,0,0)
res.optim <- optim(AA.0,func.2.minimize,
Y = u, distri = distri,
gr = d.func.2.minimize,
method="Nelder-Mead",
control=list(trace=FALSE,maxit=1000))
AA.0 <- res.optim$par
res.optim <- optim(AA.0,func.2.minimize,d.func.2.minimize,
Y = u, distri = distri,
method="BFGS",
control=list(trace=FALSE))
AA.est <- res.optim$par
n <- ncol(Y)
M <- make.M(n)
A.est <- matrix(M %*% AA.est,n,n)
C.PML <- (diag(n) + A.est) %*% solve(diag(n) - A.est)
eps.PML <- u %*% C.PML # eps.PML are the ICA-estimated structural shocks
library(tseries)
c(jarque.bera.test(eps.PML[,1]),
jarque.bera.test(eps.PML[,2]),
jarque.bera.test(eps.PML[,3]))
A <- make.A.matrix(eps.PML,distri,C.PML)
Omega <- make.Omega(eps.PML,distri)
# Compute asymptotic covariance matrix of C.PML:
V <- make.Asympt.Cov.delta(eps.PML,distri,C.PML)
param <- c(C.PML)
st.dev <- sqrt(diag(V))
t.stat <- c(C.PML)/sqrt(diag(V))
cbind(param,st.dev,t.stat) # print results of PML estimation
library(AEC)
First.date <- "1959-04-01"
Last.date  <- "2015-01-01"
data <- US3var
data <- data[(data$Date>=First.date)&(data$Date<=Last.date),]
Y <- as.matrix(data[c("infl","y.gdp.gap","r")])
names.var <- c("inflation","real activity","short-term rate")
T <- dim(Y)[1]
n <- dim(Y)[2]
nb.lags <- 6 # number of lags used in the VAR model
X <- NULL
for(i in 1:nb.lags){
lagged.Y <- rbind(matrix(NaN,i,n),Y[1:(T-i),])
X <- cbind(X,lagged.Y)}
X <- cbind(X,data$commo) # add exogenous variables
Phi <- matrix(0,n,n*nb.lags);mu <- rep(0,n)
effect.commo <- rep(0,n)
U <- NULL # Eta is the matrix of OLS residuals
for(i in 1:n){
eq <- lm(Y[,i] ~ X)
Phi[i,] <- eq$coef[2:(dim(Phi)[2]+1)]
mu[i] <- eq$coef[1]
U <- cbind(Eta,eq$residuals)
effect.commo[i] <- eq$coef[length(eq$coef)]
}
Omega <- var(U) # Omega_1 is the covariance matrix of the OLS residuals.
B <- t(chol(Omega)) # B_1 is the Cholesky matrix associated with Omega_1 (lower triangular)
nb.lags <- 6 # number of lags used in the VAR model
X <- NULL
for(i in 1:nb.lags){
lagged.Y <- rbind(matrix(NaN,i,n),Y[1:(T-i),])
X <- cbind(X,lagged.Y)}
X <- cbind(X,data$commo) # add exogenous variables
Phi <- matrix(0,n,n*nb.lags);mu <- rep(0,n)
effect.commo <- rep(0,n)
U <- NULL # Eta is the matrix of OLS residuals
for(i in 1:n){
eq <- lm(Y[,i] ~ X)
Phi[i,] <- eq$coef[2:(dim(Phi)[2]+1)]
mu[i] <- eq$coef[1]
U <- cbind(Eta,eq$residuals)
effect.commo[i] <- eq$coef[length(eq$coef)]
}
Omega <- var(U) # Omega_1 is the covariance matrix of the OLS residuals.
Omega
nb.lags <- 6 # number of lags used in the VAR model
X <- NULL
for(i in 1:nb.lags){
lagged.Y <- rbind(matrix(NaN,i,n),Y[1:(T-i),])
X <- cbind(X,lagged.Y)}
X <- cbind(X,data$commo) # add exogenous variables
Phi <- matrix(0,n,n*nb.lags);mu <- rep(0,n)
effect.commo <- rep(0,n)
U <- NULL # Eta is the matrix of OLS residuals
for(i in 1:n){
eq <- lm(Y[,i] ~ X)
Phi[i,] <- eq$coef[2:(dim(Phi)[2]+1)]
mu[i] <- eq$coef[1]
U <- cbind(U,eq$residuals)
effect.commo[i] <- eq$coef[length(eq$coef)]
}
Omega <- var(U) # Omega_1 is the covariance matrix of the OLS residuals.
B <- t(chol(Omega)) # B_1 is the Cholesky matrix associated with Omega_1 (lower triangular)
Eps <- U %*% t(solve(B)) # Recover associated structural shocks
nb.lags <- 6 # number of lags used in the VAR model
X <- NULL
for(i in 1:nb.lags){
lagged.Y <- rbind(matrix(NaN,i,n),Y[1:(T-i),])
X <- cbind(X,lagged.Y)}
X <- cbind(X,data$commo) # add exogenous variables
Phi <- matrix(0,n,n*nb.lags);mu <- rep(0,n)
effect.commo <- rep(0,n)
U <- NULL # Eta is the matrix of OLS residuals
for(i in 1:n){
eq <- lm(Y[,i] ~ X)
Phi[i,] <- eq$coef[2:(dim(Phi)[2]+1)]
mu[i] <- eq$coef[1]
U <- cbind(U,eq$residuals)
effect.commo[i] <- eq$coef[length(eq$coef)]
}
Omega <- var(U) # Omega_1 is the covariance matrix of the OLS residuals.
B <- t(chol(Omega)) # B_1 is the Cholesky matrix associated with Omega_1 (lower triangular)
Eps <- U %*% t(solve(B)) # Recover associated structural shocks
distri <- list(
type=c("mixt.gaussian","mixt.gaussian","mixt.gaussian"),
df=c(NaN,NaN,NaN),
p=c(0.5,.5,.5),mu=c(.1,.1,.1),sigma=c(.5,.7,1.3))
AA.0 <- c(0,0,0)
res.optim <- optim(AA.0,func.2.minimize,
Y = Eps, distri = distri,
gr = d.func.2.minimize,
method="Nelder-Mead",
control=list(trace=FALSE,maxit=1000))
AA.0 <- res.optim$par
res.optim <- optim(AA.0,func.2.minimize,d.func.2.minimize,
Y = Eps, distri = distri,
method="BFGS",
control=list(trace=FALSE))
AA.est <- res.optim$par
n <- ncol(Y)
M <- make.M(n)
A.est <- matrix(M %*% AA.est,n,n)
C.PML <- (diag(n) + A.est) %*% solve(diag(n) - A.est)
eta.PML <- u %*% C.PML # eta.PML are the ICA-estimated structural shocks
A <- make.A.matrix(eta.PML,distri,C.PML)
Omega <- make.Omega(eta.PML,distri)
# Compute asymptotic covariance matrix of C.PML:
V <- make.Asympt.Cov.delta(eta.PML,distri,C.PML)
param <- c(C.PML)
st.dev <- sqrt(diag(V))
t.stat <- c(C.PML)/sqrt(diag(V))
cbind(param,st.dev,t.stat) # print results of PML estimation
IRF.Chol <- array(NaN,c(n,41,n))
IRF.ICA  <- array(NaN,c(n,41,n))
PHI <- list();for(i in 1:nb.lags){PHI[[i]]<-array(Phi,c(3,3,nb.lags))[,,i]}
for(jjjj in 1:n){
u.shock <- rep(0,n)
u.shock[jjjj] <- 1
IRF.Chol[,,jjjj] <- t(simul.VAR(c=rep(0,3),Phi=PHI,B=B,nb.sim=41,
y0.star=rep(0,3*nb.lags),indic.IRF = 1,u.shock = u.shock))
IRF.ICA[,,jjjj]  <- t(simul.VAR(c=rep(0,3),Phi=PHI,B=B%*%C.PML,nb.sim=41,
y0.star=rep(0,3*nb.lags),indic.IRF = 1,u.shock = u.shock))
}
# Plot Cholesky-based IRFs:
par(mfrow=c((n+1),n))
par(plt=c(.25,.9,.1,.7))
for(i in 1:n){
par(mfg=c(1,i))
plot(IRF.Chol[i,,3],type="l",col="red",lwd=2,
main=paste("Response of ",names.var[i],sep=""),ylab="MP shock (Chol.)")
abline(h=0,col="grey")
}
for(shock in 1:n){
for(iii in 1:n){
par(mfg=c(shock+1,iii))
plot(IRF.ICA[iii,,shock],type="l",lwd=2,ylab=paste("Shock ",shock," (ICA)",sep=""))
abline(h=0,col="grey")
}
}
